# EatWise — Restaurant Management System
- Comprehensive project repository for a simple restaurant management web app named "EatWise". This repository includes a React + Vite frontend and a Node.js backend that connects to a MySQL database. The database, schema, test data, and triggers are provided in this repository as well
- Created as a project for Database Management Systems Lab (CSL333) in Semester 5 (S5) of Bachelor of Technology (BTech) in Computer Science and Engineering (CSE) in APJ Abdul Kalam Technological University (KTU)

---

## Contents of this repository
- `frontend/` — React (Vite) single-page application. UI components, pages, and assets live here
- `backend/` — Node.js Express server (single-file `index.js`) that exposes API endpoints used by the frontend and connects to the MySQL database
- `restaurant_schema.sql` — SQL dump containing schema, table definitions, sample data and triggers
- `order_suborder_triggers.sql` — Simplified trigger definitions used to keep order totals consistent
- `readme.md` — This file (project documentation)

---

## Project overview (high level)
EatWise is a small restaurant application to demonstrate relational database design, CRUD operations, and use of triggers to maintain derived/calculated columns. It supports two user roles: Admin and Customer. Key features:
- Browsing menu items
- Placing orders (customers create orders and add order items)
- Viewing and managing orders, users, reviews, menu items (admin)
- Simple authentication based on the `users` table (username + password stored in DB; used for demo only)
- Database triggers that automatically update order totals when order items are added/updated/deleted

---

## Schema summary
Main tables and primary columns (see `restaurant_schema.sql` for full definitions and sample rows):
- `users` (user_id PK, username, password, email, role)
- `menu_items` (item_id PK, item_name, category, price, item_picture)
- `orders` (order_id PK, user_id FK -> users.user_id, order_date_time, total_amount)
- `order_items` (order_items_id PK, order_id FK -> orders.order_id, item_id FK -> menu_items.item_id, quantity, suborder_price)
- `reviews` (review_id PK, user_id FK -> users.user_id, description, date, rating)

Important relationships:
- `users(user_id)` -> `orders(user_id)`
- `menu_items(item_id)` -> `order_items(item_id)`
- `orders(order_id)` -> `order_items(order_id)`
- `users(user_id)` -> `reviews(user_id)`

Auto-increment is enabled on the appropriate primary keys (see `restaurant_schema.sql`). Do not change those columns unless you know the consequences — the frontend/backend depend on auto-increment behavior for IDs

---

## Triggers
The repository includes triggers that keep `orders.total_amount` consistent with the sum of `order_items.suborder_price` for each order. Triggers are provided in two places: the dump `restaurant_schema.sql` (generated by mysqldump) and the simplified `order_suborder_triggers.sql` file

Behavior:
- After inserting an `order_items` row, the `trg_orderitems_insert` trigger recalculates and updates the corresponding `orders.total_amount`.
- After updating an `order_items` row, `trg_orderitems_update` recalculates total.
- After deleting an `order_items` row, `trg_orderitems_delete` recalculates total.

These triggers ensure there is a single source of truth for order totals and avoid having the application perform aggregation logic for every change

---

## Setup — local development (Windows)
Prerequisites
- Node.js (v16+ recommended)
- npm (comes with Node.js)
- MySQL Community Server (8.x recommended)

Steps
1. Clone or download this repository to a local folder

2. Import the database schema and sample data into MySQL

	- Using MySQL Workbench or the command line, create/import the `restaurant_schema.sql` file. This will:
	  - create the database `restaurant_schema` (if not exists)
	  - create tables and sample rows
	  - create triggers (the dump contains trigger definitions)

	- To import via command line (PowerShell), run (adjust path and MySQL credentials as needed):

```powershell
mysql -u root -p < "C:\Users\aravindanirudh\Downloads\restaurant-management-system\restaurant_schema.sql"
```
	- If you prefer, you can run the smaller `order_suborder_triggers.sql` after importing the schema to ensure the triggers exist

3. Install dependencies for frontend and backend
- Frontend:
```powershell
cd frontend
npm install
```
- Backend:
```powershell
cd ..\backend
npm install
```

4. Configure MySQL credentials used by the backend
- Open `backend/index.js` and update the connection settings (host, user, password, database) if your MySQL install uses different credentials. By default the project used the password 'Aravind2005' during authoring — change it for your environment

5. Run the app
- Start the backend server (opens an API port; see `backend/index.js` for the port used):
```powershell
cd backend
npm run dev
```
- Start the frontend (Vite dev server):
```powershell
cd ../frontend
npm run dev
```

6. Open the frontend in your browser. Vite will show a local URL (typically `http://localhost:5173`) — open it to see the app

Notes
- If ports are in use, Vite or the backend server will either pick a different port or fail. Adjust the commands or kill conflicting processes
- The app uses in-database credential checking. Passwords in the sample DB are plain-text for demo only — do not use this approach in production

---

## How the system works — short technical contract
Inputs
- HTTP requests from the frontend to the Node.js backend (REST endpoints)
- MySQL database (the `restaurant_schema`)

Outputs
- JSON responses from the backend
- Changes in the database (CRUD operations on tables)

Success criteria
- Frontend lists menu items and reviews from the DB
- Customers can create an order; `orders` and `order_items` tables receive rows
- Triggers correctly update `orders.total_amount` after insert/update/delete in `order_items`

Error modes
- DB connection failures (wrong credentials, server not running)
- Constraint / foreign key violations (for example, inserting an order_item with an unknown item_id)

---

## How to verify triggers and DB correctness (quick tests)
Use MySQL shell or Workbench. Example operations (replace `root` and password as appropriate):

1. Check existing orders and their totals:
```sql
USE restaurant_schema;
SELECT * FROM orders LIMIT 10;
SELECT * FROM order_items WHERE order_id = 8;
```

2. Insert an order item and verify the `orders.total_amount` updates
```sql

-- create a new order for user_id=2 (if desired)
INSERT INTO orders (user_id, order_date_time, total_amount) VALUES (2, NOW(), 0);
SET @order_id = LAST_INSERT_ID();

-- add an order item (item_id must exist in menu_items)
INSERT INTO order_items (order_id, item_id, quantity, suborder_price) VALUES (@order_id, 1, 2, 80);

-- the trigger should have updated the order total
SELECT * FROM orders WHERE order_id = @order_id;
```

3. Update or delete an order_item and ensure the order total recalculates.
If the trigger isn't present (for example, your import skipped it), you can apply `order_suborder_triggers.sql` to create them

---

## Frontend structure and entry points
- `index.html` -> bootstraps the SPA
- `src/main.jsx` -> React entry point
- `src/App.jsx` -> App shell and routing
- `src/pages/*` -> Page components (Homepage, Login, AdminLanding, CustomerLanding, MenuItems, Reviews, Add, Update, ProtectedRoute)

---

## Backend quick notes
- `backend/index.js` contains Express routes and a MySQL connection pool
- Update the MySQL config at the top of `index.js` to match your environment
- The backend provides CRUD endpoints for the frontend; consult the source to see exact routes and payloads

---

## Security & limitations
- Passwords in `users` are stored as plain text for demonstration. For any production or grading that expects secure practice, note this limitation and propose using hashed passwords (bcrypt) and proper authentication flows
- No role-based authorization middleware beyond simple role checks in the frontend. The backend is minimal and trusts frontend input in places — be mindful when extending

---

## Final notes and troubleshooting
- If you see errors connecting to MySQL, verify the server is running and that credentials in `backend/index.js` match
- If triggers failed to import, re-run `order_suborder_triggers.sql` and ensure your user has privileges to create triggers
- If the frontend fails to load assets or hot reload, run `npm install` again in `frontend` and restart the dev server
- If proper dependencies are not installed, error will be logged in console. Just right click on the webpage > Inspect Element > Console
- Commonly, axios might have to be installed in backend/frontend using `npm i axios` in bash terminal if it doesn't install with `npm install`

---

## Credits & contact
- Project author: [Aravind A Kamath](https://github.com/aravindanirudh)